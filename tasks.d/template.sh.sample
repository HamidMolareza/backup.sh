#!/usr/bin/env bash
# Minimal task template (ignored if *.sample)
# Runner exports:
#   TMP_BACKUP_DIR      -> where to write artifacts
#   NON_INTERACTIVE     -> "1" for non-interactive mode
#   WAIT_TO_PRESS_ENTER -> optional helper function

set -uo pipefail

# ---- helper: simple pause if interactive ----
pause() {
  if declare -F WAIT_TO_PRESS_ENTER >/dev/null; then
    WAIT_TO_PRESS_ENTER
  else
    read -r -p "Press ENTER to continue..." _
  fi
}

# ---- basics ----
task_name="$(basename "${BASH_SOURCE[0]}" .sh)"
dest_base="${TMP_BACKUP_DIR:-./output/.tasks}"
task_dir="${dest_base}/${task_name}"
mkdir -p "$task_dir"

# tiny logger to stderr (shows in console and in main log)
log(){ printf "[TASK %s] %s\n" "$task_name" "$*" >&2; }

log "Writing artifacts to: $task_dir"

# ---- do a tiny bit of work ----
cat > "${task_dir}/README.txt" <<EOF
Task: ${task_name}
Date: $(date -Iseconds)
Host: $(hostname 2>/dev/null || echo unknown)
Note: This is a template artifact.
EOF

# optional restore helper
cat > "${task_dir}/restore.sh" <<'SH'
#!/usr/bin/env bash
set -euo pipefail
here="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
echo "[restore] Contents of $here:"
ls -lah "$here" || true
echo "[restore] Nothing to restore for this template."
SH
chmod +x "${task_dir}/restore.sh"

# one simple call:
pause

log "Done."
exit 0
